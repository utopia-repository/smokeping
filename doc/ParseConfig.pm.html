<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>ParseConfig.pm</title>
<link rev="made" href="mailto:dws@ee.ethz.ch" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->
<!--

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#grammar_definition">Grammar Definition</a></li>
		<ul>

			<li><a href="#special_section_keys">Special Section Keys</a></li>
			<li><a href="#special_variable_keys">Special Variable Keys</a></li>
			<li><a href="#special_table_keys">Special Table Keys</a></li>
			<li><a href="#special_text_keys">Special Text Keys</a></li>
		</ul>

		<li><a href="#configuration_syntax">Configuration Syntax</a></li>
		<ul>

			<li><a href="#general_syntax">General Syntax</a></li>
			<li><a href="#sections">Sections</a></li>
			<li><a href="#assignments">Assignments</a></li>
			<li><a href="#tabular_data">Tabular Data</a></li>
		</ul>

		<li><a href="#example">Example</a></li>
		<ul>

			<li><a href="#code">Code</a></li>
			<li><a href="#configuration">Configuration</a></li>
			<li><a href="#result">Result</a></li>
		</ul>

	</ul>

	<li><a href="#copyright">COPYRIGHT</a></li>
	<li><a href="#license">LICENSE</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#history">HISTORY</a></li>
</ul>
-->
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>ISG::ParseConfig - Simple config parser</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 use ISG::ParseConfig;</pre>
<pre>
 my $parser = ISG::ParseConfig-&gt;new(\%grammar);
 my $cfg = $parser-&gt;parse('app.cfg') or die &quot;ERROR: $parser-&gt;{err}\n&quot;;
 my $pod = $parser-&gt;makepod();
 my $ex = $parser-&gt;maketmpl('TOP','SubNode');</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>ISG::ParseConfig is a module to parse configuration files. The
configuration may consist of multiple-level sections with assignments
and tabular data. The parsed data will be returned as a hash
containing the whole configuration. ISG::ParseConfig uses a grammar
that is supplied upon creation of a ISG::ParseConfig object to parse
the configuration file and return helpful error messages in case of
syntax errors. Using the <strong>makepod</strong> methode you can generate
documentation of the configuration file format.</p>
<p>The <strong>maketmpl</strong> method can generate a template configuration file.  If
your grammar contains regexp matches, the template will not be all
that helpful as ParseConfig is not smart enough to give you sensible
template data based in regular expressions.</p>
<p>
</p>
<h2><a name="grammar_definition">Grammar Definition</a></h2>
<p>The grammar is a multiple-level hash of hashes, which follows the structure of
the configuration. Each section or variable is represented by a hash with the
same structure.  Each hash contains special keys starting with an underscore
such as '_sections', '_vars', '_sub' or '_re' to denote meta data with information
about that section or variable. Other keys are used to structure the hash
according to the same nesting structure of the configuration itself. The
starting hash given as parameter to 'new' contains the ``root section''.</p>
<p>
</p>
<h3><a name="special_section_keys">Special Section Keys</a></h3>
<dl>
<dt><strong><a name="item__sections">_sections</a></strong><br />
</dt>
<dd>
Array containing the list of sub-sections of this section. Each sub-section
must then be represented by a sub-hash in this hash with the same name of the
sub-section.
</dd>
<dd>
<p>The sub-section can also be a regular expression denoted by the syntax '/re/',
where re is the regular-expression. In case a regular expression is used, a
sub-hash named with the same '/re/' must be included in this hash.</p>
</dd>
<p></p>
<dt><strong><a name="item__recursive">_recursive</a></strong><br />
</dt>
<dd>
Array containing the list of those sub-sections that are <em>recursive</em>, ie.
that can contain a new sub-section with the same syntax as themselves.
</dd>
<dd>
<p>The same effect can be accomplished with circular references in the
grammar tree or a suitable <strong>_dyn</strong> section subroutine (see below},
so this facility is included just for convenience.</p>
</dd>
<p></p>
<dt><strong><a name="item__vars">_vars</a></strong><br />
</dt>
<dd>
Array containing the list of variables (assignments) in this section.
Analogous to sections, regular expressions can be used.
</dd>
<p></p>
<dt><strong><a name="item__mandatory">_mandatory</a></strong><br />
</dt>
<dd>
Array containing the list of mandatory sections and variables.
</dd>
<p></p>
<dt><strong><a name="item__inherited">_inherited</a></strong><br />
</dt>
<dd>
Array containing the list of the variables that should be assigned the
same value as in the parent section if nothing is specified here.
</dd>
<p></p>
<dt><strong><a name="item__table">_table</a></strong><br />
</dt>
<dd>
Hash containing the table grammar (see Special Table Keys). If not specified,
no table is allowed in this section. The grammar of the columns if specified
by sub-hashes named with the column number.
</dd>
<p></p>
<dt><strong><a name="item__text">_text</a></strong><br />
</dt>
<dd>
Section contains free-form text. Only sections and @includes statements will
be interpreted, the rest will be added in the returned hash under '_text' as
string.
</dd>
<dd>
<p><strong>_text</strong> is a hash reference which can contain a <strong>_re</strong> and a <strong>_re_error</strong> key
which will be used to scrutanize the text ... if the hash is empty, all text
will be accepted.</p>
</dd>
<p></p>
<dt><strong><a name="item__order">_order</a></strong><br />
</dt>
<dd>
If defined, a '_order' element will be put in every hash containing the
sections with a number that determines the order in which the sections were
defined.
</dd>
<p></p>
<dt><strong><a name="item__varlist">_varlist</a></strong><br />
</dt>
<dd>
If defined, a '_varlist' element will be put in the config hash of this
section with a list of the variables defined in the section. This can
be used to find out the order of the variable assignments.
</dd>
<dd>
<p>The '_sub' function (see below) of any variables defined in this section
will also receive a list of those variables already defined in the
same section. This can be used to enforce the order of the variables
during parsing.</p>
</dd>
<p></p>
<dt><strong><a name="item__doc">_doc</a></strong><br />
</dt>
<dd>
Describes what this section is about
</dd>
<p></p>
<dt><strong><a name="item__sub">_sub</a></strong><br />
</dt>
<dd>
A function pointer. It is called for every instance of this section,
with the real name of the section passed as its first argument. This is
probably only useful for the regexp sections. If the function returns
a defined value it is assumed that the test was not successful and an
error is generated with the returned string as content.
</dd>
<p></p>
<dt><strong><a name="item__dyn">_dyn</a></strong><br />
</dt>
<dd>
A subroutine reference (function pointer) that will be called when
a new section of this syntax is encountered. The subroutine will get
three arguments: the syntax of the section name (string or regexp), the
actual name encountered (this will be the same as the first argument for
non-regexp sections) and a reference to the grammar tree of the section.
This subroutine can then modify the grammar tree dynamically.
</dd>
<p></p>
<dt><strong><a name="item__dyndoc">_dyndoc</a></strong><br />
</dt>
<dd>
A hash reference that lists interesting names for the section that
should be documented. The keys of the hash are the names and the
values in the hash are strings that can contain an explanation
for the name. The <a href="#item__dyn"><code>_dyn()</code></a> subroutine is then called for each of 
these names and the differences of the resulting grammar and
the original one are documented. This module can currently document
differences in the _vars list, listing new variables and removed
ones, and differences in the _sections list, listing the
new and removed sections.
</dd>
<p></p></dl>
<p>
</p>
<h3><a name="special_variable_keys">Special Variable Keys</a></h3>
<dl>
<dt><strong><a name="item__re">_re</a></strong><br />
</dt>
<dd>
Regular expression upon which the value will be checked.
</dd>
<p></p>
<dt><strong><a name="item__re_error">_re_error</a></strong><br />
</dt>
<dd>
String containing the returned error in case the regular expression doesn't
match (if not specified, a generic 'syntax error' message will be returned).
</dd>
<p></p>
<dt><strong>_sub</strong><br />
</dt>
<dd>
A function pointer. It called for every value, with the value passed as its
first argument. If the function returns a defined value it is assumed that
the test was not successful and an error is generated with the returned
string as content.
</dd>
<dd>
<p>If the '_varlist' key (see above) is defined in this section, the '_sub'
function will also receive an array reference as the second argument. The
array contains a list of those variables already defined in the same
section. This can be used to enforce the order of the variables.</p>
</dd>
<p></p>
<dt><strong><a name="item__default">_default</a></strong><br />
</dt>
<dd>
A default value that will be assigned to the variable if none is specified or inherited.
</dd>
<p></p>
<dt><strong>_doc</strong><br />
</dt>
<dd>
Description of the variable.
</dd>
<p></p>
<dt><strong><a name="item__example">_example</a></strong><br />
</dt>
<dd>
A one line example for the content of this variable.
</dd>
<p></p>
<dt><strong>_dyn</strong><br />
</dt>
<dd>
A subroutine reference (function pointer) that will be called when the
variable is assigned some value in the config file. The subroutine will
get three arguments: the name of the variable, the value assigned and
a reference to the grammar tree of this section.  This subroutine can
then modify the grammar tree dynamically.
</dd>
<dd>
<p>Note that no <a href="#item__dyn"><code>_dyn()</code></a> call is made for default and inherited values of
the variable.</p>
</dd>
<p></p>
<dt><strong>_dyndoc</strong><br />
</dt>
<dd>
A hash reference that lists interesting values for the variable that
should be documented. The keys of the hash are the values and the
values in the hash are strings that can contain an explanation
for the value. The <a href="#item__dyn"><code>_dyn()</code></a> subroutine is then called for each of 
these values and the differences of the resulting grammar and
the original one are documented. This module can currently document
differences in the _vars list, listing new variables and removed
ones, and differences in the _sections list, listing the
new and removed sections.
</dd>
<p></p></dl>
<p>
</p>
<h3><a name="special_table_keys">Special Table Keys</a></h3>
<dl>
<dt><strong><a name="item__columns">_columns</a></strong><br />
</dt>
<dd>
Number of columns. If not specified, it will not be enforced.
</dd>
<p></p>
<dt><strong><a name="item__key">_key</a></strong><br />
</dt>
<dd>
If defined, the specified column number will be used as key in a hash in the
returned hash. If not defined, the returned hash will contain a '_table'
element with the contents of the table as array. The rows of the tables are
stored as arrays.
</dd>
<p></p>
<dt><strong>_sub</strong><br />
</dt>
<dd>
they work analog to the description in the previous section.
</dd>
<p></p>
<dt><strong>_doc</strong><br />
</dt>
<dd>
describes the content of the column.
</dd>
<p></p>
<dt><strong>_example</strong><br />
</dt>
<dd>
example for the content of this column
</dd>
<p></p></dl>
<p>
</p>
<h3><a name="special_text_keys">Special Text Keys</a></h3>
<dl>
<dt><strong>_re</strong><br />
</dt>
<dd>
Regular expression upon which the text will be checked (everything as a single
line).
</dd>
<p></p>
<dt><strong>_re_error</strong><br />
</dt>
<dd>
String containing the returned error in case the regular expression doesn't
match (if not specified, a generic 'syntax error' message will be returned).
</dd>
<p></p>
<dt><strong>_sub</strong><br />
</dt>
<dd>
they work analog to the description in the previous section.
</dd>
<p></p>
<dt><strong>_doc</strong><br />
</dt>
<dd>
Ditto.
</dd>
<p></p>
<dt><strong>_example</strong><br />
</dt>
<dd>
Potential multi line example for the content of this text section
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="configuration_syntax">Configuration Syntax</a></h2>
<p>
</p>
<h3><a name="general_syntax">General Syntax</a></h3>
<p>'#' denotes a comment up to the end-of-line, empty lines are allowed and space
at the beginning and end of lines is trimmed.</p>
<p>'\' at the end of the line marks a continued line on the next line. A single
space will be inserted between the concatenated lines.</p>
<p>'@include filename' is used to include another file.</p>
<p>'@define a some value' will replace all occurences of 'a' in the following text
with 'some value'.</p>
<p>Fields in tables that contain white space can be enclosed in either <code>'</code> or <code>&quot;</code>.
Whitespace can also be escaped with <code>\</code>. Quotes inside quotes are allowed but must
be escaped with a backslash as well.</p>
<p>
</p>
<h3><a name="sections">Sections</a></h3>
<p>ISG::ParseConfig supports hierarchical configurations through sections, whose
syntax is as follows:</p>
<dl>
<dt><strong><a name="item_level_1">Level 1</a></strong><br />
</dt>
<dd>
*** section name ***
</dd>
<p></p>
<dt><strong><a name="item_level_2">Level 2</a></strong><br />
</dt>
<dd>
+ section name
</dd>
<p></p>
<dt><strong><a name="item_level_3">Level 3</a></strong><br />
</dt>
<dd>
++ section name
</dd>
<p></p>
<dt><strong><a name="item_level_n_2c_n_3e1">Level n, n&gt;1</a></strong><br />
</dt>
<dd>
+..+ section name (number of '+' determines level)
</dd>
<p></p></dl>
<p>
</p>
<h3><a name="assignments">Assignments</a></h3>
<p>Assignements take the form: 'variable = value', where value can be any string
(can contain whitespaces and special characters). The spaces before and after
the equal sign are optional.</p>
<p>
</p>
<h3><a name="tabular_data">Tabular Data</a></h3>
<p>The data is interpreted as one or more columns separated by spaces.</p>
<p>
</p>
<h2><a name="example">Example</a></h2>
<p>
</p>
<h3><a name="code">Code</a></h3>
<pre>
 my $parser = ISG::ParseConfig-&gt;new({
   _sections =&gt; [ 'network', 'hosts' ],
   network =&gt; {
      _vars     =&gt; [ 'dns' ],
      _sections =&gt; [ &quot;/$RE_IP/&quot; ],
      dns       =&gt; {
         _doc =&gt; &quot;address of the dns server&quot;,
         _example =&gt; &quot;ns1.oetiker.xs&quot;,
         _re =&gt; $RE_HOST,
         _re_error =&gt;
            'dns must be an host name or ip address',
         },
      &quot;/$RE_IP/&quot; =&gt; {
         _doc    =&gt; &quot;Ip Adress&quot;,
         _example =&gt; '10.2.3.2',
         _vars   =&gt; [ 'netmask', 'gateway' ],
         netmask =&gt; {
            _doc =&gt; &quot;Netmask&quot;,
            _example =&gt; &quot;255.255.255.0&quot;,
            _re =&gt; $RE_IP,
            _re_error =&gt;
               'netmask must be a dotted ip address'
            },
         gateway =&gt; {
            _doc =&gt; &quot;Default Gateway address in IP notation&quot;,
            _example =&gt; &quot;10.22.12.1&quot;,
            _re =&gt; $RE_IP,
            _re_error =&gt;
               'gateway must be a dotted ip address' },
         },
      },
   hosts =&gt; {
      _doc =&gt; &quot;Details about the hosts&quot;,
      _table  =&gt; {
          _doc =&gt; &quot;Description of all the Hosts&quot;,
         _key =&gt; 0,
         _columns =&gt; 3,
         0 =&gt; {
            _doc =&gt; &quot;Ethernet Address&quot;,
            _example =&gt; &quot;0:3:3:d:a:3:dd:a:cd&quot;,
            _re =&gt; $RE_MAC,
            _re_error =&gt;
               'first column must be an ethernet mac address',
            },
         1 =&gt; {
            _doc =&gt; &quot;IP Address&quot;,
            _example =&gt; &quot;10.11.23.1&quot;,
            _re =&gt; $RE_IP,
            _re_error =&gt;
               'second column must be a dotted ip address',
            },
         2 =&gt; {
            _doc =&gt; &quot;Host Name&quot;,
            _example =&gt; &quot;tardis&quot;,
             },
         },
      },
   });</pre>
<pre>
 my $cfg = $parser-&gt;parse('test.cfg') or
   die &quot;ERROR: $parser-&gt;{err}\n&quot;;
 print Dumper($cfg);
 print $praser-&gt;makepod;</pre>
<p>
</p>
<h3><a name="configuration">Configuration</a></h3>
<pre>
 *** network ***
  
   dns      = 129.132.7.87
  
 + 129.132.7.64
 
   netmask  = 255.255.255.192
   gateway  = 129.132.7.65
  
 *** hosts ***
 
   00:50:fe:bc:65:11     129.132.7.97    plain.hades
   00:50:fe:bc:65:12     129.132.7.98    isg.ee.hades
   00:50:fe:bc:65:14     129.132.7.99    isg.ee.hades</pre>
<p>
</p>
<h3><a name="result">Result</a></h3>
<pre>
 {
   'hosts' =&gt; {
                '00:50:fe:bc:65:11' =&gt; [
                                         '00:50:fe:bc:65:11',
                                         '129.132.7.97',
                                         'plain.hades'
                                       ],
                '00:50:fe:bc:65:12' =&gt; [
                                         '00:50:fe:bc:65:12',
                                         '129.132.7.98',
                                         'isg.ee.hades'
                                       ],
                '00:50:fe:bc:65:14' =&gt; [
                                         '00:50:fe:bc:65:14',
                                         '129.132.7.99',
                                         'isg.ee.hades'
                                       ]
              },
   'network' =&gt; {
                  '129.132.7.64' =&gt; {
                                      'netmask' =&gt; '255.255.255.192',
                                      'gateway' =&gt; '129.132.7.65'
                                    },
                  'dns' =&gt; '129.132.7.87'
                }
 };</pre>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright (c) 2000, 2001 by ETH Zurich. All rights reserved.</p>
<p>
</p>
<hr />
<h1><a name="license">LICENSE</a></h1>
<p>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>David&nbsp;Schweikert&nbsp;&lt;<a&nbsp;href="mailto:dws@ee.ethz.ch">dws@ee.ethz.ch</a>&gt;
Tobias&nbsp;Oetiker&nbsp;&lt;<a&nbsp;href="mailto:oetiker@ee.ethz.ch">oetiker@ee.ethz.ch</a>&gt;</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<pre>
 2001-05-11 ds 1.2  Initial Version for policy 0.3
 2001-09-04 ds 1.3  Remove space before comments, more strict variable definition
 2001-09-19 to 1.4  Added _sub error parsing and _doc self documentation
 2001-10-20 to      Improved Rendering of _doc information
 2002-01-09 to      Added Documentation to the _text section documentation
 2002-01-28 to      Fixed quote parsing in tables
 2002-03-12 ds 1.5  Implemented @define, make makepod return a string and not an array
 2002-08-28 to      Added maketmpl methode
 2002-10-10 ds 1.6  More verbatim _text sections
 2004-02-09 to 1.7  Added _example propperty for pod and template generation
 2004-08-17 to 1.8  Allow special input files like &quot;program|&quot;
 2005-01-10 ds 1.9  Implemented _dyn, _default, _recursive, and _inherited (Niko Tyni) 
 2005-02-21 ds 2.00 Implemented _dyndoc, _varlist and _sub for sections (Niko Tyni)</pre>

</body>

</html>
